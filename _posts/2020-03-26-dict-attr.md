---
layout: post
published: true
title: Python Dict Accessed by Dot 
subtitle: Wow
date: '2020-03-26'
---

### Python Accessing Dict Items through Dot

[reference](https://stackoverflow.com/questions/2352181/how-to-use-a-dot-to-access-members-of-dictionary)

All lines below will show the result which you expect.

```python
class config(dict):
    __getattr__ = dict.__getitem__
    __setattr__ = dict.__setitem__
    __delattr__ = dict.__delitem__
    
from pprint import pprint

a = config()
a.integer = 1
a.string = "hi"
a.nested = config({"nested_key" : "nested_string"})
a['from_bracket'] = True

pprint(a)
print("\033[1m#Access items\033[0m")
print(a.integer, a['integer'])
print(a.string)
print(a.nested)
print(a.nested.nested_key)
print(a.from_bracket)

print("\033[1m#Use method\033[0m")
print(a.keys())
print(a.values())
print(a.items())
print(a.get("integer"))
b=a.copy()
print(f"copied : {b}")

print("\033[1m#Updates from dict\033[0m")
a.update({"new_key" : "new_value"})
print(a)

print("\033[1m#Updates from this new type\033[0m")
a.update(config({"by_config_type" : "1"}))
print(a)
```



### Loading json with this custom dictionary.

이거 하려고 metaclass 까지 찾고 헛고생을 했지만, 문득 json의 소스코드를 봐볼까 ? 라는 생각이 들었고, 모든게 해결되었다. json 소스코드를 깊게 알 필요는 없고 딱 parameter만 보면 감이 잡힌다. 사실 `json.load()` 쓰면서 그냥 파일포인터 넣을 생각만 하고있었는데, `object_hook`이 있는게 아닌가.

```python
with open(filepath, 'r') as f:
    _data = json.load(f, object_hook= lambda dict: config(dict))
    return _data
```

```python
class config(dict):
    __getattr__ = dict.__getitem__
    __setattr__ = dict.__setitem__
    __delattr__ = dict.__delitem__
```

Json으로 로드할때 nested는 죽어도 끝까지 dict로만 되던 것이 위 방법으로써 해결됐다.

